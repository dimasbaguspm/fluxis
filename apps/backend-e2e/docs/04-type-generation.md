# Type Generation from OpenAPI

## Overview

The backend-e2e project uses **openapi-typescript** to automatically generate TypeScript types from the OpenAPI specification. This ensures **type safety** and keeps tests synchronized with the backend API contract.

## Source of Truth

The single source of truth for API types is:

```
/api/openapi.yaml
```

This file is **generated by the backend** (using Huma framework) and contains:

- Complete API schema definitions
- Request/response models
- Validation rules
- Endpoint paths and operations

## Type Generation Workflow

```
┌─────────────────────────────┐
│  Backend (Go + Huma)        │
│  - Generates OpenAPI spec   │
└──────────┬──────────────────┘
           │
           │ Writes to
           ▼
┌─────────────────────────────┐
│  /api/openapi.yaml          │  ← Single source of truth
│  - Schemas                  │
│  - Paths                    │
│  - Operations               │
└──────────┬──────────────────┘
           │
           │ npm run generate:types
           │ (scripts/generate-openapi-types.ts)
           ▼
┌─────────────────────────────┐
│  types/openapi.ts           │  ← Generated TypeScript types
│  - components["schemas"]    │
│  - operations               │
│  - paths                    │
└──────────┬──────────────────┘
           │
           │ import { components } from "../types/openapi"
           │
           ▼
┌─────────────────────────────┐
│  fixtures/{entity}-client.ts│  ← Type-safe API clients
│  - Uses generated types     │
└──────────┬──────────────────┘
           │
           │ test.use(fixture)
           │
           ▼
┌─────────────────────────────┐
│  specs/**/*.spec.ts         │  ← Type-safe tests
│  - Autocomplete             │
│  - Compile-time validation  │
└─────────────────────────────┘
```

## Generator Script

Located at: `scripts/generate-openapi-types.ts`

### How It Works

```typescript
import { execSync } from "child_process";
import fs from "fs";
import path from "path";

const OPENAPI_YAML_PATH = path.resolve(__dirname, "../../../api/openapi.yaml");
const OUTPUT_DIR = path.resolve(__dirname, "../types");

function generateTypes(yamlPath: string, outPath: string) {
  execSync(`npx openapi-typescript ${yamlPath} -o ${outPath}`, {
    stdio: "inherit",
  });
}

async function generateAllTypes() {
  try {
    const typesOutPath = path.join(OUTPUT_DIR, "openapi.ts");

    // Check if openapi.yaml exists
    if (!fs.existsSync(OPENAPI_YAML_PATH)) {
      throw new Error(`OpenAPI file not found at ${OPENAPI_YAML_PATH}`);
    }

    console.log(`Reading OpenAPI spec from ${OPENAPI_YAML_PATH}`);

    // Generate TypeScript types from the YAML file
    generateTypes(OPENAPI_YAML_PATH, typesOutPath);

    console.log("✅ Generated openapi.ts");
    console.log("✅ OpenAPI types generated successfully!");
  } catch (error) {
    console.error("❌ Failed to generate OpenAPI types:", error);
    process.exit(1);
  }
}

generateAllTypes();
```

### Running the Generator

```bash
npm run generate:types
```

**What happens**:

1. Script reads `/api/openapi.yaml`
2. Invokes `openapi-typescript` CLI tool
3. Generates TypeScript types to `types/openapi.ts`
4. Reports success/failure

### When to Run

Run the generator whenever:

- ✅ Backend API changes (new endpoints, modified schemas)
- ✅ After pulling changes from Git (if openapi.yaml updated)
- ✅ Before writing tests for new features
- ✅ As part of CI/CD pipeline
- ✅ When TypeScript shows type errors in API calls

## Generated Type Structure

The `types/openapi.ts` file contains three main exports:

### 1. Components (Schemas)

```typescript
export interface components {
  schemas: {
    AuthLoginInputModel: {
      /* ... */
    };
    AuthLoginOutputModel: {
      /* ... */
    };
    ProjectModel: {
      /* ... */
    };
    ProjectCreateModel: {
      /* ... */
    };
    ProjectUpdateModel: {
      /* ... */
    };
    ProjectPaginatedModel: {
      /* ... */
    };
    // ... all other models
  };
  // ... other component types
}
```

**Usage**:

```typescript
import type { components } from "../types/openapi";

type LoginRequest = components["schemas"]["AuthLoginInputModel"];
type LoginResponse = components["schemas"]["AuthLoginOutputModel"];
```

### 2. Operations

```typescript
export interface operations {
  login: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthLoginInputModel"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AuthLoginOutputModel"];
        };
      };
    };
  };
  // ... all other operations
}
```

**Usage**:

```typescript
import type { operations } from "../types/openapi";

type LoginOperation = operations["login"];
type LoginRequestBody =
  LoginOperation["requestBody"]["content"]["application/json"];
type LoginSuccessResponse =
  LoginOperation["responses"][200]["content"]["application/json"];
```

### 3. Paths

```typescript
export interface paths {
  "/auth/login": {
    post: operations["login"];
  };
  "/projects": {
    get: operations["project-get-paginated"];
    post: operations["project-create"];
  };
  "/projects/{projectId}": {
    get: operations["project-get-detail"];
    patch: operations["project-update"];
    delete: operations["project-delete"];
  };
  // ... all other paths
}
```

**Usage** (less common):

```typescript
import type { paths } from "../types/openapi";

type ProjectsGetOperation = paths["/projects"]["get"];
```

## Using Generated Types in Fixtures

### Example: Auth API Client

```typescript
import { APIRequestContext } from "@playwright/test";
import { BaseAPIClient } from "./base-client";
import type { TestContext, APIResponse } from "../types/common";
import type { components } from "../types/openapi";

// Extract types from generated schemas
export type LoginRequestModel = components["schemas"]["AuthLoginInputModel"];
export type LoginResponseModel = components["schemas"]["AuthLoginOutputModel"];
export type RefreshRequestModel =
  components["schemas"]["AuthRefreshInputModel"];
export type RefreshResponseModel =
  components["schemas"]["AuthRefreshOutputModel"];

export class AuthAPIClient extends BaseAPIClient {
  constructor(request: APIRequestContext, context: TestContext) {
    super(request, context);
  }

  async login(
    username: string,
    password: string
  ): Promise<APIResponse<LoginResponseModel>> {
    //                    ^^^^^^^^^^^^^^^^^^^^
    //                    Type-safe response
    const response = await this.post<LoginResponseModel>("/auth/login", {
      username,
      password,
    });

    if (response.data) {
      // TypeScript knows the shape of response.data
      this.context.accessToken = response.data.accessToken;
      //                                      ^^^^^^^^^^^^ Autocomplete available
      this.context.refreshToken = response.data.refreshToken;
    }

    return response;
  }
}
```

### Example: Project API Client

```typescript
import type { components } from "../types/openapi";

export type ProjectCreateRequest = components["schemas"]["ProjectCreateModel"];
export type ProjectResponse = components["schemas"]["ProjectModel"];
export type ProjectPaginatedResponse =
  components["schemas"]["ProjectPaginatedModel"];
export type ProjectUpdateRequest = components["schemas"]["ProjectUpdateModel"];

export class ProjectAPIClient extends BaseAPIClient {
  async create(
    data: ProjectCreateRequest
  ): Promise<APIResponse<ProjectResponse>> {
    return this.post<ProjectResponse>("/projects", data);
  }

  async getPaginated(params?: {
    page?: number;
    limit?: number;
  }): Promise<APIResponse<ProjectPaginatedResponse>> {
    return this.get<ProjectPaginatedResponse>("/projects", params);
  }

  async update(
    id: string,
    data: ProjectUpdateRequest
  ): Promise<APIResponse<ProjectResponse>> {
    return this.patch<ProjectResponse>(`/projects/${id}`, data);
  }
}
```

## Type Safety Benefits

### 1. Compile-Time Validation

```typescript
// ✅ CORRECT - TypeScript validates structure
const response = await authAPI.login("user", "pass");
if (response.data) {
  console.log(response.data.accessToken); // ✅ Valid
}

// ❌ COMPILE ERROR - Property doesn't exist
console.log(response.data.invalidField);
//                        ^^^^^^^^^^^^^ Error: Property 'invalidField' does not exist
```

### 2. Autocomplete

```typescript
const response = await projectAPI.create({
  name: "Project",
  description: "Description",
  status: "active",
  // IDE shows available fields:
  // - name (required)
  // - description (optional)
  // - status (required)
});

// Accessing response data
if (response.data) {
  response.data.  // ← Autocomplete shows: id, name, description, status, createdAt, updatedAt
}
```

### 3. Refactoring Safety

When backend changes:

```yaml
# Backend changes "status" to "projectStatus" in openapi.yaml
ProjectModel:
  properties:
    projectStatus: # Renamed from "status"
      type: string
```

After regenerating types:

```typescript
// ❌ COMPILE ERROR - TypeScript catches the change
const status = response.data.status;
//                           ^^^^^^ Error: Property 'status' does not exist

// ✅ CORRECT - Update to new field name
const status = response.data.projectStatus;
```

### 4. Required vs Optional Fields

Generated types reflect OpenAPI schema:

```typescript
// From openapi.yaml:
// ProjectCreateModel:
//   required: [name, status]
//   properties:
//     name: string
//     description: string (optional)
//     status: string

type ProjectCreateRequest = components["schemas"]["ProjectCreateModel"];

// TypeScript enforces required fields
const request: ProjectCreateRequest = {
  name: "Project", // ✅ Required
  status: "active", // ✅ Required
  // description is optional, not needed
};

// ❌ COMPILE ERROR - Missing required field
const invalid: ProjectCreateRequest = {
  name: "Project",
  // Missing "status" field
};
```

## Keeping Types in Sync

### Workflow

1. **Backend developer** updates API:

   - Modifies Go structs with Huma tags
   - Backend regenerates `openapi.yaml`

2. **Frontend/E2E developer** syncs:

   ```bash
   git pull origin main        # Get latest openapi.yaml
   npm run generate:types      # Regenerate TypeScript types
   ```

3. **TypeScript compiler** catches breaking changes:

   ```
   error TS2339: Property 'oldFieldName' does not exist on type 'ProjectModel'
   ```

4. **Update affected code**:
   - Fix API client methods
   - Update test assertions
   - Commit changes

### CI/CD Integration

Add to your CI pipeline:

```yaml
# .github/workflows/test.yml
name: E2E Tests

jobs:
  test:
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3

      # Generate types before running tests
      - name: Generate OpenAPI Types
        working-directory: apps/backend-e2e
        run: npm run generate:types

      # Types must be up-to-date
      - name: Check for uncommitted changes
        run: |
          git diff --exit-code types/openapi.ts

      # Run tests with type-checked code
      - name: Run Tests
        working-directory: apps/backend-e2e
        run: npm test
```

## Common Issues and Solutions

### Issue: Types not updating

**Symptom**: Generated types don't reflect latest openapi.yaml changes

**Solution**:

```bash
# Delete generated file and regenerate
rm types/openapi.ts
npm run generate:types
```

### Issue: Import errors

**Symptom**: `Cannot find module '../types/openapi'`

**Solution**:

```bash
# Ensure types are generated
npm run generate:types

# Check TypeScript configuration
cat tsconfig.json  # Ensure "types/" is in include paths
```

### Issue: Type mismatches

**Symptom**: Tests fail with type errors after backend changes

**Solution**:

```bash
# Regenerate types
npm run generate:types

# TypeScript will show all affected locations
npx tsc --noEmit

# Update code to match new types
```

### Issue: openapi.yaml not found

**Symptom**: `OpenAPI file not found at /api/openapi.yaml`

**Solution**:

```bash
# Ensure backend has generated the spec
cd apps/backend
go run cmd/app/main.go  # Starts server and generates openapi.yaml

# Or copy from backend output
cp apps/backend/openapi.yaml api/openapi.yaml
```

## Best Practices

### ✅ DO

- **Regenerate types** after pulling changes from Git
- **Commit generated types** to version control
- **Run type generation** before writing new tests
- **Use type aliases** for better readability:
  ```typescript
  export type LoginRequest = components["schemas"]["AuthLoginInputModel"];
  export type LoginResponse = components["schemas"]["AuthLoginOutputModel"];
  ```
- **Leverage autocomplete** in your IDE
- **Trust the compiler** - Fix type errors, don't use `any`

### ❌ DON'T

- **Don't manually edit** `types/openapi.ts` (it will be overwritten)
- **Don't use `any` or `@ts-ignore`** to bypass type errors
- **Don't duplicate type definitions** - Use generated types
- **Don't skip type generation** before running tests
- **Don't ignore type errors** - They indicate API contract changes

## Example: Complete Type Flow

### 1. Backend Defines Schema (Go)

```go
// internal/models/project_model.go
type ProjectCreateModel struct {
    Name        string `json:"name" required:"true"`
    Description string `json:"description"`
    Status      string `json:"status" required:"true" enum:"active,archived"`
}

type ProjectModel struct {
    ID          uuid.UUID `json:"id"`
    Name        string    `json:"name"`
    Description string    `json:"description"`
    Status      string    `json:"status"`
    CreatedAt   time.Time `json:"createdAt"`
    UpdatedAt   time.Time `json:"updatedAt"`
}
```

### 2. Backend Generates OpenAPI (Automatic)

```yaml
# api/openapi.yaml
components:
  schemas:
    ProjectCreateModel:
      type: object
      required:
        - name
        - status
      properties:
        name:
          type: string
        description:
          type: string
        status:
          type: string
          enum: [active, archived]

    ProjectModel:
      type: object
      required:
        - id
        - name
        - status
        - createdAt
        - updatedAt
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        description:
          type: string
        status:
          type: string
        createdAt:
          type: string
          format: date-time
        updatedAt:
          type: string
          format: date-time
```

### 3. Generate TypeScript Types

```bash
npm run generate:types
```

### 4. Generated Types (Automatic)

```typescript
// types/openapi.ts
export interface components {
  schemas: {
    ProjectCreateModel: {
      name: string;
      description?: string;
      status: "active" | "archived";
    };
    ProjectModel: {
      id: string;
      name: string;
      description?: string;
      status: string;
      createdAt: string;
      updatedAt: string;
    };
  };
}
```

### 5. Use in API Client

```typescript
// fixtures/project-client.ts
import type { components } from "../types/openapi";

export type ProjectCreateRequest = components["schemas"]["ProjectCreateModel"];
export type ProjectResponse = components["schemas"]["ProjectModel"];

export class ProjectAPIClient extends BaseAPIClient {
  async create(
    data: ProjectCreateRequest
  ): Promise<APIResponse<ProjectResponse>> {
    return this.post<ProjectResponse>("/projects", data);
  }
}
```

### 6. Use in Tests (Type-Safe)

```typescript
// specs/projects/projects.spec.ts
import { test, expect } from "../../fixtures";

test("should create project", async ({ projectAPI }) => {
  const response = await projectAPI.create({
    name: "Test Project",
    status: "active",
    // TypeScript validates: name (required), status (required, enum)
  });

  expect(response.status).toBe(200);
  expect(response.data?.id).toBeDefined();
  expect(response.data?.name).toBe("Test Project");
  // TypeScript provides autocomplete for all fields
});
```

## Summary

Type generation provides:

- **Single source of truth** - OpenAPI spec drives TypeScript types
- **Type safety** - Compile-time validation of API contracts
- **Autocomplete** - IDE assistance for API fields
- **Refactoring safety** - Catch breaking changes immediately
- **Documentation** - Types serve as living documentation

**Workflow**:

1. Backend generates `openapi.yaml`
2. Run `npm run generate:types`
3. Use generated types in fixtures
4. Write type-safe tests
5. TypeScript catches API contract violations at compile time

This architecture ensures tests are always synchronized with the backend API, catching contract violations before runtime.
